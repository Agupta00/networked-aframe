<html>
  <head>
    <meta charset="utf-8" />
    <title>Tracked Controllers — Networked-Aframe</title>
    <meta name="description" content="Tracked Controllers — Networked-Aframe" />

    <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
    
    <!--   NAF basic requirements   -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.5.0/socket.io.slim.js"></script>
    <script src="/easyrtc/easyrtc.js"></script>
    <script src="/dist/networked-aframe.js"></script>
    
    <!--    used for flying in this demo  -->
    <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v6.1.1/dist/aframe-extras.min.js"></script> 
    
    <!--   used for the pretty environment   -->
    <script src="https://unpkg.com/aframe-environment-component@1.3.1/dist/aframe-environment-component.min.js"></script>
    
    <!--   used to prevent players from spawning on top of each other so much  -->
    <script src="/js/spawn-in-circle.component.js"></script>    
    
    <script>
      // Called by Networked-Aframe when connected to server (optional)
      // (this api will change in future versions)
      function onConnect() {
        console.log('onConnect', new Date());
      }
      
      // Note the way we're establishing the NAF schema here; this is a bit awkward
      // because of a recent bug found in the original handling. This mitigates that bug for now,
      // until a refactor in the future that should fix the issue more cleanly.
      NAF.schemas.getComponentsOriginal = NAF.schemas.getComponents;

      // This one is necessary, because tracking the .head child component's material's color
      // won't happen unless we tell NAF to keep it in sync, like here.
      NAF.schemas.getComponents = (template) => {
        if (!NAF.schemas.hasTemplate('#head-template')) {
          NAF.schemas.add({
            template: '#head-template',
            components: [
              // position and rotation are synced by default, but if we declare
              // a custom schema, then ommitting them will cause them to go untracked.
              'position',
              'rotation',

              // In our current example, we don't sync the material.color itself;
              // we instead sync player-info, which includes color setting + updating.
              // if we did, though, this is what that would look like:
              // {
              //   selector: '.head',
              //   component: 'material',
              //   property: 'color'
              // },

              // NOTICE THAT WE SYNC PLAYER INFO! this is where color and username are stored
              'player-info'
            ]
          });
        }

        // We could theoretically add this one in as well, but
        // since position and rotation are the default tracked components for
        // networked entities, no schema declaration is necessary. If we did
        // include it, though, it would look like this:

        // if (!NAF.schemas.hasTemplate("#camera-rig-template")) {
        //   NAF.schemas.add({
        //     template: '#camera-rig-template',
        //      components: [
        //       'position',
        //       'rotation',
        //     ]
        //   });
        // }
        
        // here we add in the networked-hand-controls component; by syncing this component, 
        // NAF will track the gestures and the visibility as specified in the schema
        if (!NAF.schemas.hasTemplate("#left-hand-template")) {
          NAF.schemas.add({
            template: '#left-hand-template',
             components: [
              'position',
              'rotation',
              'networked-hand-controls', // optimization: could consider doing only visibility and gesture
            ]
          });
        }
        if (!NAF.schemas.hasTemplate("#right-hand-template")) {
          NAF.schemas.add({
            template: '#right-hand-template',
             components: [
              'position',
              'rotation',
              'networked-hand-controls',
            ]
          });
        }        

        const components = NAF.schemas.getComponentsOriginal(template);
        return components;
      };
    </script>
    
    <script>
      AFRAME.registerComponent('player-info', {
        schema: {
          name: { type: 'string', default: 'user-' + Math.round(Math.random() * 10000) },
          color: {
            type: 'string',
            default: '#' + new THREE.Color(Math.random(), Math.random(), Math.random()).getHexString()
          }
        },

        init: function () {
          this.head = this.el.querySelector('.head');
          this.nametag = this.el.querySelector('.nametag');
          this.ownedByLocalUser = this.el.id === 'player';
          if (this.ownedByLocalUser) {
            this.nametagInput = document.getElementById('username-overlay');
            this.nametagInput.value = this.data.name;
          }
        },

        listUsers: function () {
          console.log(
            'userlist',
            [...document.querySelectorAll('[player-info]')].map((el) => el.components['player-info'].data.name)
          );
        },

        update: function () {
          if (this.head) this.head.setAttribute('material', 'color', this.data.color);
          if (this.nametag) this.nametag.setAttribute('value', this.data.name);
        }
      });
    </script>
  </head>

  <body>
    <input
      id="username-overlay"
      style="z-index: 100; bottom: 24px; left: 24px; position: fixed"
      oninput="document.getElementById('player').setAttribute('player-info', 'name', this.value)"
    />
    <a-scene
      networked-scene="
        room: handcontrollers;
        debug: true;
        adapter: wseasyrtc;
    "
    >
      <a-assets>
        <!--
          NAF Templates
        -->
        <!-- Camera Rig / Player -->
        <template id="camera-rig-template">
          <a-entity></a-entity>
        </template>

        <!-- Head / Avatar -->
        <!--      a few spheres make a head + eyes + pupils    -->
        <template id="head-template">
          <a-entity class="avatar" player-info>
            <a-sphere class="head" scale="0.2 0.22 0.2"></a-sphere>
            <a-entity class="face" position="0 0.05 0">
              <a-sphere class="eye" color="white" position="0.06 0.05 -0.16" scale="0.04 0.04 0.04">
                <a-sphere class="pupil" color="black" position="0 0 -1" scale="0.2 0.2 0.2"></a-sphere>
              </a-sphere>
              <a-sphere class="eye" color="white" position="-0.06 0.05 -0.16" scale="0.04 0.04 0.04">
                <a-sphere class="pupil" color="black" position="0 0 -1" scale="0.2 0.2 0.2"></a-sphere>
              </a-sphere>
            </a-entity>
            <a-text
              class="nametag"
              value="?"
              rotation="0 180 0"
              position=".25 -.35 0"
              side="double"
              scale=".5 .5 .5"
            ></a-text>
          </a-entity>
        </template>

        <!-- Hands -->
        <template id="left-hand-template">
          <a-entity networked-hand-controls="hand: left;"></a-entity>
        </template>

        <template id="right-hand-template">
          <a-entity networked-hand-controls="hand: right;"></a-entity>
        </template>
        <!--
          /NAF Templates
        -->
      </a-assets>

      <a-entity environment="preset:starry;groundColor:#000000;"></a-entity>
      <a-entity light="type:ambient;intensity:0.5"></a-entity>

      <!--   Here we declare only the local user's avatar, which we then broadcast to other users     -->
      <!--   The 'spawn-in-circle' component will set the position and rotation of #cameraRig;
             because this entity also has the networked component, and position and rotation are tracked by default,
             the changes made by spawn-in-circle will be kept in sync with other networked users.
             Also note that by adding the networked component with a template reference, we generate that full template,
             including all applicable child elements. However, because we don't need to see our own avatar, we use the
             `attachTemplateToLocal:false` option. This makes our local copies invisible on our machine, but visible on everyone else's.
      -->
      <a-entity
        id="cameraRig"
        movement-controls="fly:true;"
        spawn-in-circle="radius:3"
        networked="template:#camera-rig-template;"
      >
        <a-entity
          id="player"
          camera
          position="0 1.6 0"
          look-controls
          networked="template:#head-template;"
          visible="false"
        >
          <!-- Here we add the camera. Adding the camera within a 'rig' is standard practice.
             We set the camera to head height for e.g. computer users, but otherwise never touch it again; if the user enters VR,
             its rotation and position will be updated by the headset in VR. If we need to touch the user's position
             or rotation, we always do that by adjusting the rig parent of the active camera. By making that rig--and the
             active camera appended to it--both networked, we ensure all player movement is kept in sync.
            -->
        </a-entity>
        
          <!-- here we add the user's local hands! note the separate local-naf-hand class; that's required to function properly! -->
          <!-- in the component init function is code that causes hands to only show up if a webXR 'controllerconnected' event fires -->
        <a-entity id="my-tracked-left-hand" class="local-naf-hand" networked="template: #left-hand-template; attachTemplateToLocal: true;"></a-entity>
        <a-entity id="my-tracked-right-hand" class="local-naf-hand" networked="template: #right-hand-template; attachTemplateToLocal: true;"></a-entity>
        
      </a-entity>
    </a-scene>

    <script>
      // old style sync schema declaration, can cause race condition glitch--use new style, shown at top of file

      // Define custom schema for syncing avatar color, set by random-color
      // NAF.schemas.add({
      //   template: '#head-template',
      //   components: [
      //     'position',
      //     'rotation',
      //     {
      //       selector: '.head',
      //       component: 'material',
      //       property: 'color'
      //     }
      //   ]
      // });

      // NAF.schemas.add({
      //   template: '#camera-rig-template',
      //   components: [
      //     'position',
      //     'rotation'
      //   ]
      // });
    </script>
  </body>
</html>
